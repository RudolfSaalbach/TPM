<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard - Chronos Engine</title>

    <!-- Inter Font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">

    <!-- Premium CSS -->
    <link rel="stylesheet" href="/static/css/chronos-momentum.css">

    <!-- Zentrale Chronos Config Injection -->
    <script>
        window.CHRONOS_CONFIG = {
            API_KEY: 'super-secret-change-me',
            API_BASE: 'http://localhost:8080',
            VERSION: '2.2.0',
            ENVIRONMENT: 'development'
        };
    </script>
</head>
<body>
    <!-- Skip Link f√ºr Barrierefreiheit -->
    <a href="#main-content" class="skip-link">Zum Hauptinhalt springen</a>

    <div class="app-container">
        <!-- Sidebar Overlay f√ºr Mobile -->
        <div class="sidebar-overlay" id="sidebarOverlay" onclick="closeSidebar()"></div>

        <!-- Sidebar Navigation -->
        <nav class="sidebar" id="sidebar" role="navigation" aria-label="Hauptnavigation">
            <div class="sidebar-header">
                <a href="/" class="logo">
                    <div class="logo-icon" aria-hidden="true">‚è∞</div>
                    <span class="logo-text">Chronos</span>
                </a>
            </div>

            <div class="sidebar-nav">
                <a href="/dashboard" class="nav-item active" aria-current="page">
                    <div class="nav-item-indicator"></div>
                    <span class="nav-icon" role="img" aria-label="Dashboard">üìä</span>
                    <span>Dashboard</span>
                </a>
                <a href="/calendar" class="nav-item">
                    <div class="nav-item-indicator"></div>
                    <span class="nav-icon" role="img" aria-label="Kalender">üìÖ</span>
                    <span>Kalender</span>
                </a>
                <a href="/events" class="nav-item">
                    <div class="nav-item-indicator"></div>
                    <span class="nav-icon" role="img" aria-label="Events">üìã</span>
                    <span>Events</span>
                </a>
                <a href="/analytics" class="nav-item">
                    <div class="nav-item-indicator"></div>
                    <span class="nav-icon" role="img" aria-label="Analytics">üìà</span>
                    <span>Analytics</span>
                </a>
                <a href="/settings" class="nav-item">
                    <div class="nav-item-indicator"></div>
                    <span class="nav-icon" role="img" aria-label="Einstellungen">‚öôÔ∏è</span>
                    <span>Einstellungen</span>
                </a>
            </div>
        </nav>

        <!-- Main Content Area -->
        <main class="main-content" id="main-content">
            <!-- Header -->
            <header class="header">
                <div class="header-content">
                    <div class="header-title">
                        <h1>Dashboard</h1>
                        <p class="header-subtitle">Willkommen zur√ºck! Hier ist deine √úbersicht f√ºr heute.</p>
                    </div>
                    <div class="header-actions">
                        <button class="btn btn-secondary" onclick="toggleSidebar()" aria-label="Seitenleiste umschalten">
                            <span aria-hidden="true">‚ò∞</span>
                        </button>
                        <button class="btn btn-secondary" onclick="refreshDashboard()" aria-label="Dashboard aktualisieren">
                            <span aria-hidden="true">üîÑ</span>
                            Aktualisieren
                        </button>
                        <button class="btn btn-primary" onclick="syncCalendar()" aria-label="Kalendersynchronisation starten">
                            <span aria-hidden="true">‚ö°</span>
                            Sync starten
                        </button>
                    </div>
                </div>
            </header>

            <!-- Dashboard Content -->
            <div class="dashboard-content animate-fade-in">
                <!-- Stats Grid -->
                <section aria-labelledby="stats-heading">
                    <h2 id="stats-heading" class="sr-only">Leistungsmetriken</h2>
                    <div class="stats-grid animate-stagger">
                        <article class="metric-card">
                            <div class="metric-header">
                                <span class="metric-label">Gesamte Events</span>
                                <div class="metric-icon" aria-hidden="true">üìÖ</div>
                            </div>
                            <div class="metric-value" id="totalEvents">8</div>
                            <div class="metric-change positive" id="eventsChange">
                                <span aria-label="Anstieg">‚Üó</span>
                                <span>+18% diese Woche</span>
                            </div>
                        </article>

                        <article class="metric-card">
                            <div class="metric-header">
                                <span class="metric-label">Produktivit√§tsrate</span>
                                <div class="metric-icon" aria-hidden="true">üéØ</div>
                            </div>
                            <div class="metric-value" id="productivityRate">87.3%</div>
                            <div class="metric-change positive" id="productivityChange">
                                <span aria-label="Anstieg">‚Üó</span>
                                <span>+5.2% vs. letzten Monat</span>
                            </div>
                        </article>

                        <article class="metric-card">
                            <div class="metric-header">
                                <span class="metric-label">Focus Time</span>
                                <div class="metric-icon" aria-hidden="true">‚è±Ô∏è</div>
                            </div>
                            <div class="metric-value" id="timeSaved">11.8h</div>
                            <div class="metric-change positive" id="timeSavedChange">
                                <span aria-label="Anstieg">‚Üó</span>
                                <span>+30min heute</span>
                            </div>
                        </article>

                        <article class="metric-card">
                            <div class="metric-header">
                                <span class="metric-label">Abgeschlossene Tasks</span>
                                <div class="metric-icon" aria-hidden="true">‚úÖ</div>
                            </div>
                            <div class="metric-value" id="completedTasks">0</div>
                            <div class="metric-change negative" id="tasksChange">
                                <span aria-label="R√ºckgang">‚Üì</span>
                                <span>-3 vs. gestern</span>
                            </div>
                        </article>

                        <article class="metric-card">
                            <div class="metric-header">
                                <span class="metric-label">Sync Status</span>
                                <div class="metric-icon" aria-hidden="true">üîÑ</div>
                            </div>
                            <div class="metric-value" style="font-size: 18px;" id="syncStatus">
                                <span class="status-indicator active" aria-hidden="true"></span>
                                Verbunden
                            </div>
                            <div class="metric-change neutral" id="lastUpdate">
                                vor 3 Min
                            </div>
                        </article>

                        <article class="metric-card">
                            <div class="metric-header">
                                <span class="metric-label">CalDAV Events</span>
                                <div class="metric-icon" aria-hidden="true">üìä</div>
                            </div>
                            <div class="metric-value" id="caldavEvents">0</div>
                            <div class="metric-change positive" id="caldavChange">
                                <span aria-label="Anstieg">‚Üó</span>
                                <span>+7 neue Events</span>
                            </div>
                        </article>
                    </div>
                </section>

                <!-- Charts Section -->
                <section aria-labelledby="charts-heading">
                    <h2 id="charts-heading" class="sr-only">Diagramme</h2>
                    <div class="charts-grid">
                        <div class="chart-card">
                            <div class="chart-header">
                                <div>
                                    <h3 class="chart-title">Wochen√ºbersicht</h3>
                                    <p class="chart-subtitle analytics-period-label">Produktivit√§t der letzten 7 Tage</p>
                                </div>
                                <div class="chart-actions" style="display: flex; gap: var(--space-2); align-items: center;">
                                    <div class="time-range-buttons" style="display: flex; gap: 2px;">
                                        <button class="btn btn-sm time-range-button" data-range="7d" onclick="setTimeRange('7d')" style="padding: 4px 8px; font-size: 12px;">7T</button>
                                        <button class="btn btn-sm time-range-button active" data-range="30d" onclick="setTimeRange('30d')" style="padding: 4px 8px; font-size: 12px;">30T</button>
                                        <button class="btn btn-sm time-range-button" data-range="90d" onclick="setTimeRange('90d')" style="padding: 4px 8px; font-size: 12px;">90T</button>
                                    </div>
                                    <div class="chart-type-buttons" style="display: flex; gap: 2px;">
                                        <button class="btn btn-sm chart-type-button active" data-chart="productivity" data-type="bar" onclick="switchChartType('productivity', 'bar')" title="Balkendiagramm" style="padding: 4px 6px; font-size: 12px;">üìä</button>
                                        <button class="btn btn-sm chart-type-button" data-chart="productivity" data-type="line" onclick="switchChartType('productivity', 'line')" title="Liniendiagramm" style="padding: 4px 6px; font-size: 12px;">üìà</button>
                                        <button class="btn btn-sm chart-type-button" data-chart="productivity" data-type="area" onclick="switchChartType('productivity', 'area')" title="Fl√§chendiagramm" style="padding: 4px 6px; font-size: 12px;">üìâ</button>
                                    </div>
                                </div>
                            </div>
                            <div class="chart-placeholder productivity-chart" data-chart="productivity" role="img" aria-label="S√§ulendiagramm der Wochenproduktivit√§t">
                                <div class="chart-bar" style="height: 60%"></div>
                                <div class="chart-bar" style="height: 80%"></div>
                                <div class="chart-bar" style="height: 70%"></div>
                                <div class="chart-bar" style="height: 90%"></div>
                                <div class="chart-bar" style="height: 85%"></div>
                                <div class="chart-bar" style="height: 95%"></div>
                                <div class="chart-bar" style="height: 75%"></div>
                            </div>
                        </div>

                        <div class="chart-card">
                            <div class="chart-header">
                                <div>
                                    <h3 class="chart-title">Priorit√§tsverteilung</h3>
                                    <p class="chart-subtitle">Aktuelle Events</p>
                                </div>
                            </div>
                            <div style="display: flex; flex-direction: column; gap: var(--space-4);">
                                <div style="display: flex; align-items: center; gap: var(--space-3);">
                                    <div style="width: 100%; height: 32px; background: linear-gradient(90deg, var(--danger-500) 25%, var(--border-subtle) 25%); border-radius: var(--radius-full);"></div>
                                    <span style="white-space: nowrap; font-size: var(--font-size-sm);">Hoch (25%)</span>
                                </div>
                                <div style="display: flex; align-items: center; gap: var(--space-3);">
                                    <div style="width: 100%; height: 32px; background: linear-gradient(90deg, var(--warning-400) 45%, var(--border-subtle) 45%); border-radius: var(--radius-full);"></div>
                                    <span style="white-space: nowrap; font-size: var(--font-size-sm);">Mittel (45%)</span>
                                </div>
                                <div style="display: flex; align-items: center; gap: var(--space-3);">
                                    <div style="width: 100%; height: 32px; background: linear-gradient(90deg, var(--success-500) 30%, var(--border-subtle) 30%); border-radius: var(--radius-full);"></div>
                                    <span style="white-space: nowrap; font-size: var(--font-size-sm);">Niedrig (30%)</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </section>

                <!-- Analytics Actions Section -->
                <section class="analytics-actions" aria-labelledby="analytics-actions-heading">
                    <div class="section-header">
                        <h2 id="analytics-actions-heading" class="chart-title">Analytics-Aktionen</h2>
                    </div>
                    <div class="analytics-controls" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: var(--space-3); margin-bottom: var(--space-6);">
                        <button class="btn btn-primary analytics-action-btn" onclick="refreshAnalytics()" style="padding: var(--space-3); display: flex; flex-direction: column; align-items: center; gap: var(--space-2);">
                            <span style="font-size: 1.5em;">üîÑ</span>
                            <span>Analytics aktualisieren</span>
                        </button>
                        <button class="btn btn-secondary analytics-action-btn" onclick="exportAnalytics()" style="padding: var(--space-3); display: flex; flex-direction: column; align-items: center; gap: var(--space-2);">
                            <span style="font-size: 1.5em;">üì•</span>
                            <span>Daten exportieren</span>
                        </button>
                        <button class="btn btn-info analytics-action-btn" onclick="generateReport()" style="padding: var(--space-3); display: flex; flex-direction: column; align-items: center; gap: var(--space-2);">
                            <span style="font-size: 1.5em;">üìä</span>
                            <span>Report generieren</span>
                        </button>
                    </div>
                </section>

                <!-- Recent Events Section -->
                <section class="events-section" aria-labelledby="events-heading">
                    <div class="section-header">
                        <h2 id="events-heading" class="chart-title">Heutige Events</h2>
                        <button class="btn btn-secondary">Alle anzeigen</button>
                    </div>

                    <div class="event-list" id="todayEventsList">
                        <!-- Events werden dynamisch √ºber loadTodayEvents() geladen -->
                        <div class="loading-events" id="eventsLoading">
                            <div class="spinner" style="width: 20px; height: 20px;"></div>
                            <span>Events werden geladen...</span>
                        </div>
                    </div>
                </section>
            </div>
        </main>
    </div>

    <!-- Floating Action Button -->
    <button class="fab" onclick="createNewEvent()" aria-label="Neues Event erstellen">
        <span aria-hidden="true">‚ûï</span>
    </button>

    <!-- Toast Container -->
    <div class="toast-container" id="toastContainer" role="region" aria-live="polite" aria-label="Benachrichtigungen"></div>

    <!-- Loading Overlay -->
    <div class="modal-overlay" id="loadingOverlay" style="display: none;" aria-hidden="true">
        <div class="spinner"></div>
    </div>

    <!-- JavaScript -->
    <script>
        // Globale Variablen
        let sidebarOpen = false;
        let currentTheme = localStorage.getItem('theme') || 'auto';

        // DOM Content Loaded
        document.addEventListener('DOMContentLoaded', function() {
            initializeApp();
            loadDashboardData();
            setupEventListeners();
        });

        // App Initialization
        function initializeApp() {
            loadSidebarState();
            applyTheme();

            // ARIA-Unterst√ºtzung f√ºr Toast-Container
            const toastContainer = document.getElementById('toastContainer');
            if (toastContainer) {
                toastContainer.setAttribute('aria-live', 'polite');
                toastContainer.setAttribute('aria-atomic', 'true');
            }
        }

        // Event Listeners Setup
        function setupEventListeners() {
            // Keyboard Navigation
            document.addEventListener('keydown', handleKeyboardNavigation);

            // Escape key f√ºr Modals
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape') {
                    closeSidebar();
                }
            });

            // Responsive Sidebar
            window.addEventListener('resize', function() {
                if (window.innerWidth > 768 && sidebarOpen) {
                    closeSidebar();
                }
            });
        }

        // Keyboard Navigation
        function handleKeyboardNavigation(e) {
            // Alt + M: Toggle Sidebar
            if (e.altKey && e.key === 'm') {
                e.preventDefault();
                toggleSidebar();
            }

            // Alt + R: Refresh Dashboard
            if (e.altKey && e.key === 'r') {
                e.preventDefault();
                refreshDashboard();
            }

            // Alt + S: Sync Calendar
            if (e.altKey && e.key === 's') {
                e.preventDefault();
                syncCalendar();
            }
        }

        // Sidebar Functions
        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            const overlay = document.getElementById('sidebarOverlay');

            if (window.innerWidth <= 768) {
                sidebarOpen = !sidebarOpen;
                sidebar.classList.toggle('open', sidebarOpen);
                overlay.classList.toggle('open', sidebarOpen);

                // ARIA
                sidebar.setAttribute('aria-hidden', !sidebarOpen);

                // Focus Management
                if (sidebarOpen) {
                    sidebar.querySelector('.nav-item').focus();
                }
            }
        }

        function closeSidebar() {
            const sidebar = document.getElementById('sidebar');
            const overlay = document.getElementById('sidebarOverlay');

            sidebarOpen = false;
            sidebar.classList.remove('open');
            overlay.classList.remove('open');
            sidebar.setAttribute('aria-hidden', 'true');
        }

        function loadSidebarState() {
            // Load nur f√ºr Desktop relevant
            if (window.innerWidth > 768) {
                const isCollapsed = localStorage.getItem('sidebarCollapsed') === 'true';
                if (isCollapsed) {
                    document.querySelector('.app-container').classList.add('sidebar-collapsed');
                }
            }
        }

        // Theme Functions
        function applyTheme() {
            const theme = localStorage.getItem('theme') || 'auto';
            document.documentElement.setAttribute('data-theme', theme);
        }

        // Dashboard Functions
        async function refreshDashboard() {
            showLoading();

            let successCount = 0;
            let totalTasks = 3;

            try {
                console.log('Starting dashboard refresh...');

                // Clear any previous errors
                const errorElements = document.querySelectorAll('.error-message');
                errorElements.forEach(el => el.remove());

                await loadDashboardData();
                successCount++;

                console.log('Dashboard refresh completed successfully');
                showToast('Dashboard aktualisiert', 'Alle Daten wurden erfolgreich geladen', 'success');

            } catch (error) {
                console.error('Dashboard refresh error:', error);
                if (successCount > 0) {
                    showToast('Teilweise erfolgreich', `${successCount}/${totalTasks} Bereiche wurden aktualisiert`, 'warning');
                } else {
                    showToast('Fehler', 'Dashboard konnte nicht aktualisiert werden. Wird mit Standarddaten fortgesetzt.', 'error');
                }
            } finally {
                hideLoading();
            }
        }

        async function syncCalendar(calendarId = null, showProgress = true) {
            const syncButton = document.querySelector('[onclick="syncCalendar()"]');

            try {
                if (syncButton) {
                    syncButton.disabled = true;
                    syncButton.innerHTML = '<span aria-hidden="true">‚è≥</span> Synchronisiere...';
                }

                if (showProgress) {
                    showToast('Synchronisation gestartet',
                        calendarId ? `Kalender ${calendarId} wird synchronisiert...` : 'Alle Kalender werden synchronisiert...',
                        'info');
                }

                let syncResults = [];

                if (calendarId) {
                    // Sync specific calendar
                    const result = await syncSingleCalendar(calendarId);
                    syncResults = [result];
                } else {
                    // Get all calendars and sync them
                    const calendarsResponse = await fetch('/caldav/calendars', {
                        headers: {
                            'Authorization': `Bearer ${window.CHRONOS_CONFIG.API_KEY}`,
                            'Accept': 'application/json'
                        }
                    });

                    if (calendarsResponse.ok) {
                        const calendarsData = await calendarsResponse.json();
                        const calendars = calendarsData.calendars || [];

                        for (const calendar of calendars) {
                            try {
                                const result = await syncSingleCalendar(calendar.id);
                                syncResults.push(result);
                            } catch (error) {
                                console.warn(`Failed to sync calendar ${calendar.id}:`, error);
                                syncResults.push({
                                    calendar_id: calendar.id,
                                    success: false,
                                    error: error.message
                                });
                            }
                        }
                    } else {
                        // Fallback to legacy sync
                        const response = await fetch('/api/v1/sync/incremental', {
                            method: 'POST',
                            headers: {
                                'Authorization': `Bearer ${window.CHRONOS_CONFIG.API_KEY}`,
                                'Content-Type': 'application/json'
                            }
                        });

                        if (!response.ok) {
                            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                        }

                        const data = await response.json();
                        syncResults = [{ success: true, message: data.message }];
                    }
                }

                // Show results
                const successCount = syncResults.filter(r => r.success).length;
                const totalCount = syncResults.length;

                if (successCount === totalCount) {
                    showToast('Sync erfolgreich',
                        `${successCount} Kalender erfolgreich synchronisiert`,
                        'success');
                } else {
                    showToast('Sync teilweise erfolgreich',
                        `${successCount}/${totalCount} Kalender synchronisiert`,
                        'warning');
                }

                await refreshDashboard();

            } catch (error) {
                console.error('Sync error:', error);
                showToast('Sync Fehler', 'Synchronisation fehlgeschlagen: ' + error.message, 'error');
            } finally {
                if (syncButton) {
                    syncButton.disabled = false;
                    syncButton.innerHTML = '<span aria-hidden="true">‚ö°</span> Sync starten';
                }
            }
        }

        async function syncSingleCalendar(calendarId) {
            const response = await fetch(`/caldav/calendars/${calendarId}/sync`, {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${window.CHRONOS_CONFIG.API_KEY}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    days_ahead: 7,
                    force_refresh: false
                })
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.detail || `HTTP ${response.status}: ${response.statusText}`);
            }

            const result = await response.json();
            return {
                calendar_id: calendarId,
                success: true,
                events_synced: result.events_processed || 0,
                message: result.message || 'Synchronisation erfolgreich'
            };
        }

        async function triggerFullSync() {
            showLoading();
            try {
                const response = await fetch('/api/v1/sync/full', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${window.CHRONOS_CONFIG.API_KEY}`,
                        'Content-Type': 'application/json'
                    }
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();
                showToast('Full Sync erfolgreich', data.message || 'Vollst√§ndige Synchronisation abgeschlossen', 'success');
                await refreshDashboard();

            } catch (error) {
                console.error('Full sync error:', error);
                showToast('Sync Fehler', 'Vollst√§ndige Synchronisation fehlgeschlagen: ' + error.message, 'error');
            } finally {
                hideLoading();
            }
        }

        // Data Loading with robust error handling
        async function loadDashboardData() {
            try {
                console.log('Loading dashboard data...');

                // Use consistent API base URL
                const apiBase = window.CHRONOS_CONFIG.API_BASE || '';

                // Load dashboard data with timeout
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 10000);

                try {
                    const response = await fetch(`${apiBase}/api/v1/dashboard-data`, {
                        signal: controller.signal,
                        headers: {
                            'Accept': 'application/json'
                        }
                    });

                    clearTimeout(timeoutId);

                    if (!response.ok) {
                        console.warn(`Dashboard API returned ${response.status}, using defaults`);
                        updateMetrics(getDefaultMetrics());
                        updateSyncStatus({ status: 'unknown', last_sync: null });
                    } else {
                        const data = await response.json();
                        console.log('Dashboard data received:', data);

                        // Update Metrics with safe defaults
                        updateMetrics(data.productivity_metrics || getDefaultMetrics());

                        // Update Sync Status
                        updateSyncStatus(data.sync_status || { status: 'unknown', last_sync: null });
                    }
                } catch (error) {
                    clearTimeout(timeoutId);
                    if (error.name === 'AbortError') {
                        console.warn('Dashboard data request timed out, using defaults');
                    } else {
                        console.warn('Dashboard data request failed:', error.message);
                    }
                    updateMetrics(getDefaultMetrics());
                    updateSyncStatus({ status: 'unknown', last_sync: null });
                }

                // Load today's events with error handling
                await loadTodayEvents();

                console.log('Dashboard data loading completed');

            } catch (error) {
                console.error('Critical error in dashboard loading:', error);
                showToast('Info', 'Dashboard wird mit Standarddaten geladen', 'info');

                // Fallback to defaults
                updateMetrics(getDefaultMetrics());
                updateSyncStatus({ status: 'unknown', last_sync: null });
            }
        }

        function getDefaultMetrics() {
            return {
                total_events: 0,
                completion_rate: 0.0,
                average_productivity: 0.0,
                total_hours: 0.0,
                events_per_day: 0.0,
                completed_events: 0
            };
        }

        async function loadTodayEvents() {
            try {
                const today = new Date().toISOString().split('T')[0];
                const apiBase = window.CHRONOS_CONFIG.API_BASE || '';

                // Add timeout and better error handling
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 8000);

                try {
                    const response = await fetch(`${apiBase}/api/v1/events?date=${today}&limit=50`, {
                        signal: controller.signal,
                        headers: {
                            'Authorization': `Bearer ${window.CHRONOS_CONFIG.API_KEY}`,
                            'Accept': 'application/json'
                        }
                    });

                    clearTimeout(timeoutId);

                    if (!response.ok) {
                        console.warn(`Events API returned ${response.status}, showing empty state`);
                        displayTodayEvents([]);
                        return;
                    }

                    const result = await response.json();
                    const events = result.events || result || [];
                    displayTodayEvents(events);

                } catch (error) {
                    clearTimeout(timeoutId);
                    if (error.name === 'AbortError') {
                        console.warn('Events request timed out');
                    } else {
                        console.warn('Events request failed:', error.message);
                    }
                    displayTodayEvents([]);
                }

            } catch (error) {
                console.error('Critical error loading today events:', error);
                const loadingElement = document.getElementById('eventsLoading');
                if (loadingElement) {
                    loadingElement.innerHTML =
                        '<p style="color: var(--text-muted); text-align: center;">Events werden geladen...</p>';
                }
            }
        }

        function displayTodayEvents(events) {
            const eventsList = document.getElementById('todayEventsList');
            const loading = document.getElementById('eventsLoading');

            if (loading) {
                loading.remove();
            }

            if (!eventsList) {
                console.warn('Events list element not found');
                return;
            }

            if (!events || events.length === 0) {
                eventsList.innerHTML = '<p style="color: var(--text-muted); text-align: center;">Keine Events f√ºr heute</p>';
                return;
            }

            // Limit display to prevent overwhelming UI with too many menu entries
            const maxDisplayEvents = 20;
            const displayEvents = events.slice(0, maxDisplayEvents);
            const hasMore = events.length > maxDisplayEvents;

            try {
                const eventsHtml = displayEvents.map(event => {
                    try {
                        const startTime = event.start_time ?
                            new Date(event.start_time).toLocaleTimeString('de-DE', {
                                hour: '2-digit',
                                minute: '2-digit'
                            }) : '??:??';

                        const endTime = event.end_time ?
                            new Date(event.end_time).toLocaleTimeString('de-DE', {
                                hour: '2-digit',
                                minute: '2-digit'
                            }) : null;

                        const duration = endTime ? ` - ${endTime}` : '';
                        const priority = event.priority || 'medium';
                        const eventId = event.id || event.uid || Math.random().toString(36);
                        const title = event.summary || event.title || 'Unbenanntes Event';
                        const description = event.description || 'Keine Beschreibung';

                        return `
                            <article class="event-item" onclick="viewEventDetails('${eventId}')" data-event-id="${eventId}">
                                <time class="event-time" datetime="${event.start_time || ''}">${startTime}${duration}</time>
                                <div class="event-details">
                                    <h3 title="${title}">${title.length > 50 ? title.substring(0, 47) + '...' : title}</h3>
                                    <p class="event-meta" title="${description}">
                                        ${description.length > 80 ? description.substring(0, 77) + '...' : description}
                                    </p>
                                </div>
                                <div class="priority-label ${priority}">
                                    <span class="sr-only">${priority === 'high' ? 'Hohe' : priority === 'low' ? 'Niedrige' : 'Mittlere'} Priorit√§t</span>
                                    ${priority === 'high' ? 'Hoch' : priority === 'low' ? 'Niedrig' : 'Mittel'}
                                </div>
                            </article>
                        `;
                    } catch (eventError) {
                        console.warn('Error rendering event:', eventError, event);
                        return '<article class="event-item error">Event konnte nicht angezeigt werden</article>';
                    }
                }).filter(html => html).join('');

                eventsList.innerHTML = eventsHtml + (hasMore ?
                    `<div class="events-more" style="text-align: center; padding: 1rem; color: var(--text-muted);">
                        <p>Und ${events.length - maxDisplayEvents} weitere Events...</p>
                        <button onclick="showAllEvents()" class="btn btn-secondary btn-sm">Alle Events anzeigen</button>
                    </div>` : '');

                console.log(`Displayed ${displayEvents.length} of ${events.length} events`);

            } catch (error) {
                console.error('Error rendering events list:', error);
                eventsList.innerHTML = '<p style="color: var(--text-danger); text-align: center;">Fehler beim Anzeigen der Events</p>';
            }
        }

        function viewEventDetails(eventId) {
            // Event-Details in Modal anzeigen
            fetch(`/api/v1/events/${eventId}`, {
                headers: {
                    'Authorization': `Bearer ${window.CHRONOS_CONFIG.API_KEY}`
                }
            })
            .then(response => response.json())
            .then(event => {
                const startTime = new Date(event.start_time).toLocaleString('de-DE');
                const endTime = event.end_time ? new Date(event.end_time).toLocaleString('de-DE') : 'Offen';

                showModal('event-details', event.summary || event.title, `
                    <div style="display: flex; flex-direction: column; gap: var(--space-4);">
                        <div>
                            <strong>Startzeit:</strong> ${startTime}
                        </div>
                        <div>
                            <strong>Endzeit:</strong> ${endTime}
                        </div>
                        ${event.description ? `
                            <div>
                                <strong>Beschreibung:</strong><br>
                                ${event.description}
                            </div>
                        ` : ''}
                        ${event.location ? `
                            <div>
                                <strong>Ort:</strong> ${event.location}
                            </div>
                        ` : ''}
                        <div>
                            <strong>Priorit√§t:</strong>
                            <span class="priority-label ${event.priority || 'medium'}">${
                                event.priority === 'high' ? 'Hoch' :
                                event.priority === 'low' ? 'Niedrig' : 'Mittel'
                            }</span>
                        </div>
                    </div>
                `, [
                    { text: 'Schlie√üen', action: 'closeModal', class: 'btn-primary' }
                ]);
            })
            .catch(error => {
                console.error('Fehler beim Laden der Event-Details:', error);
                showToast('Fehler', 'Event-Details konnten nicht geladen werden', 'error');
            });
        }

        function updateMetrics(metrics) {
            const elements = {
                totalEvents: metrics.total_events || 0,
                productivityRate: ((metrics.completion_rate || 0) * 100).toFixed(1) + '%',
                timeSaved: (metrics.total_hours || 0).toFixed(1) + 'h',
                completedTasks: metrics.completed_tasks || 0,
                caldavEvents: metrics.caldav_events || 0
            };

            Object.entries(elements).forEach(([id, value]) => {
                const element = document.getElementById(id);
                if (element) {
                    element.textContent = value;
                }
            });
        }

        function updateSyncStatus(syncStatus) {
            const lastUpdate = document.getElementById('lastUpdate');
            if (lastUpdate) {
                if (syncStatus.last_update) {
                    const updateTime = new Date(syncStatus.last_update);
                    const now = new Date();
                    const diffMinutes = Math.floor((now - updateTime) / (1000 * 60));

                    if (diffMinutes < 1) {
                        lastUpdate.textContent = 'gerade eben';
                    } else if (diffMinutes < 60) {
                        lastUpdate.textContent = `vor ${diffMinutes} Min`;
                    } else {
                        const diffHours = Math.floor(diffMinutes / 60);
                        lastUpdate.textContent = `vor ${diffHours} Std`;
                    }
                } else {
                    lastUpdate.textContent = 'Nie synchronisiert';
                }
            }
        }

        // Event Creation
        function createNewEvent() {
            showModal('event-modal', 'Neues Event erstellen', `
                <form id="eventForm">
                    <div style="display: flex; flex-direction: column; gap: var(--space-4);">
                        <div>
                            <label for="eventTitle" style="display: block; margin-bottom: var(--space-2); font-weight: var(--font-weight-medium);">Titel</label>
                            <input type="text" id="eventTitle" name="title" style="width: 100%; padding: var(--space-3); border: 1px solid var(--border-base); border-radius: var(--radius-md);" required>
                        </div>
                        <div>
                            <label for="eventDate" style="display: block; margin-bottom: var(--space-2); font-weight: var(--font-weight-medium);">Datum</label>
                            <input type="date" id="eventDate" name="date" style="width: 100%; padding: var(--space-3); border: 1px solid var(--border-base); border-radius: var(--radius-md);" required>
                        </div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: var(--space-3);">
                            <div>
                                <label for="eventTime" style="display: block; margin-bottom: var(--space-2); font-weight: var(--font-weight-medium);">Startzeit</label>
                                <input type="time" id="eventTime" name="time" style="width: 100%; padding: var(--space-3); border: 1px solid var(--border-base); border-radius: var(--radius-md);" required>
                            </div>
                            <div>
                                <label for="eventEndTime" style="display: block; margin-bottom: var(--space-2); font-weight: var(--font-weight-medium);">Endzeit</label>
                                <input type="time" id="eventEndTime" name="endTime" style="width: 100%; padding: var(--space-3); border: 1px solid var(--border-base); border-radius: var(--radius-md);" required>
                            </div>
                        </div>
                        <div>
                            <label for="eventDescription" style="display: block; margin-bottom: var(--space-2); font-weight: var(--font-weight-medium);">Beschreibung</label>
                            <textarea id="eventDescription" name="description" rows="3" style="width: 100%; padding: var(--space-3); border: 1px solid var(--border-base); border-radius: var(--radius-md); resize: vertical;"></textarea>
                        </div>
                        <div>
                            <label for="eventLocation" style="display: block; margin-bottom: var(--space-2); font-weight: var(--font-weight-medium);">Ort</label>
                            <input type="text" id="eventLocation" name="location" style="width: 100%; padding: var(--space-3); border: 1px solid var(--border-base); border-radius: var(--radius-md);">
                        </div>
                        <div>
                            <label for="eventPriority" style="display: block; margin-bottom: var(--space-2); font-weight: var(--font-weight-medium);">Priorit√§t</label>
                            <select id="eventPriority" name="priority" style="width: 100%; padding: var(--space-3); border: 1px solid var(--border-base); border-radius: var(--radius-md);">
                                <option value="low">Niedrig</option>
                                <option value="medium" selected>Mittel</option>
                                <option value="high">Hoch</option>
                                <option value="urgent">Dringend</option>
                            </select>
                        </div>
                    </div>
                </form>
            `, [
                { text: 'Abbrechen', action: 'closeModal', class: 'btn-secondary' },
                { text: 'Event erstellen', action: 'createEvent', class: 'btn-primary' }
            ]);
        }


        async function createEvent() {
            const form = document.getElementById('eventForm');
            const formData = new FormData(form);

            const eventData = {
                title: formData.get('title'),
                start_time: `${formData.get('date')}T${formData.get('time')}:00`,
                priority: formData.get('priority'),
                description: formData.get('description') || ''
            };

            try {
                const response = await fetch('/api/v1/events', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${window.CHRONOS_CONFIG.API_KEY}`
                    },
                    body: JSON.stringify(eventData)
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const result = await response.json();
                showToast('Event erstellt', `"${eventData.title}" wurde erfolgreich erstellt`, 'success');
                closeModal();

                // Dashboard neu laden um neues Event anzuzeigen
                await loadDashboardData();

            } catch (error) {
                console.error('Fehler beim Erstellen des Events:', error);
                showToast('Fehler', 'Event konnte nicht erstellt werden: ' + error.message, 'error');
            }
        }

        // Utility Functions
        function showLoading() {
            const overlay = document.getElementById('loadingOverlay');
            if (overlay) {
                overlay.style.display = 'flex';
                overlay.setAttribute('aria-hidden', 'false');
            }
        }

        function hideLoading() {
            const overlay = document.getElementById('loadingOverlay');
            if (overlay) {
                overlay.style.display = 'none';
                overlay.setAttribute('aria-hidden', 'true');
            }
        }

        // Toast System
        function showToast(title, message, type = 'info') {
            const toastContainer = document.getElementById('toastContainer') || createToastContainer();
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.setAttribute('role', 'alert');

            toast.innerHTML = `
                <div class="toast-header">
                    <h4 class="toast-title">${title}</h4>
                    <button class="toast-close" onclick="removeToast(this.parentElement.parentElement)" aria-label="Benachrichtigung schlie√üen">
                        <span aria-hidden="true">√ó</span>
                    </button>
                </div>
                <div class="toast-body">${message}</div>
            `;

            toastContainer.appendChild(toast);

            // Animate in
            setTimeout(() => {
                toast.classList.add('show');
            }, 100);

            // Auto-remove nach 8 Sekunden
            setTimeout(() => {
                removeToast(toast);
            }, 8000);
        }

        function createToastContainer() {
            const container = document.createElement('div');
            container.id = 'toastContainer';
            container.className = 'toast-container';
            container.setAttribute('role', 'region');
            container.setAttribute('aria-live', 'polite');
            container.setAttribute('aria-label', 'Benachrichtigungen');
            document.body.appendChild(container);
            return container;
        }

        function removeToast(toast) {
            if (toast && toast.parentElement) {
                toast.classList.add('fade-out');
                setTimeout(() => {
                    if (toast.parentElement) {
                        toast.remove();
                    }
                }, 400);
            }
        }

        // Performance Monitoring (optional)
        if ('performance' in window) {
            window.addEventListener('load', function() {
                const loadTime = performance.timing.loadEventEnd - performance.timing.navigationStart;
                console.log(`Dashboard geladen in ${loadTime}ms`);
            });
        }

        // Modal System
        function showModal(id, title, content, actions = '') {
            // Remove existing modal if any
            const existingModal = document.getElementById('modal-overlay');
            if (existingModal) {
                existingModal.remove();
            }

            // Create modal overlay
            const overlay = document.createElement('div');
            overlay.id = 'modal-overlay';
            overlay.className = 'modal-overlay';
            overlay.innerHTML = `
                <div class="modal-dialog" role="dialog" aria-labelledby="modal-title">
                    <div class="modal-header">
                        <h3 id="modal-title">${title}</h3>
                        <button class="modal-close" onclick="closeModal()" aria-label="Modal schlie√üen">
                            <span aria-hidden="true">√ó</span>
                        </button>
                    </div>
                    <div class="modal-body">
                        ${content}
                    </div>
                    <div class="modal-footer">
                        ${actions || '<button class="btn btn-secondary" onclick="closeModal()">Abbrechen</button><button class="btn btn-primary" onclick="submitEventForm()">Erstellen</button>'}
                    </div>
                </div>
            `;

            document.body.appendChild(overlay);

            // Show modal with animation
            setTimeout(() => {
                overlay.classList.add('show');
            }, 10);

            // Focus management
            const firstInput = overlay.querySelector('input, textarea, select, button');
            if (firstInput) firstInput.focus();
        }

        function closeModal() {
            const overlay = document.getElementById('modal-overlay');
            if (overlay) {
                overlay.classList.remove('show');
                setTimeout(() => {
                    overlay.remove();
                }, 200);
            }
        }

        function submitEventForm() {
            const form = document.getElementById('eventForm');
            if (form && form.checkValidity()) {
                const formData = new FormData(form);

                // Convert form data to event object
                const eventData = {
                    summary: formData.get('title'),
                    start_time: formData.get('date') + 'T' + formData.get('time'),
                    end_time: formData.get('date') + 'T' + formData.get('endTime'),
                    description: formData.get('description') || '',
                    location: formData.get('location') || ''
                };

                // Send to API
                fetch('/api/v1/events', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${window.CHRONOS_CONFIG.API_KEY}`
                    },
                    body: JSON.stringify(eventData)
                })
                .then(response => response.json())
                .then(result => {
                    closeModal();
                    showToast('Erfolg', 'Event erfolgreich erstellt!', 'success');
                    // Refresh dashboard data
                    setTimeout(refreshDashboard, 1000);
                })
                .catch(error => {
                    console.error('Error creating event:', error);
                    showToast('Fehler', 'Event konnte nicht erstellt werden.', 'error');
                });
            } else {
                showToast('Fehler', 'Bitte f√ºllen Sie alle Pflichtfelder aus.', 'error');
            }
        }

        // MISSING CORE FUNCTIONS - IMMEDIATE IMPLEMENTATION

        // Sidebar Management
        function closeSidebar() {
            const sidebar = document.getElementById('sidebar');
            const overlay = document.getElementById('sidebarOverlay');
            if (sidebar) sidebar.classList.remove('open');
            if (overlay) overlay.classList.remove('show');
            document.body.classList.remove('sidebar-open');
        }

        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            const overlay = document.getElementById('sidebarOverlay');
            if (sidebar && overlay) {
                sidebar.classList.toggle('open');
                overlay.classList.toggle('show');
                document.body.classList.toggle('sidebar-open');
            }
        }

        // Event Details System
        async function viewEventDetails(eventId) {
            try {
                showToast('Info', 'Lade Event-Details...', 'info');

                const response = await fetch(`/api/v1/events/${eventId}`, {
                    headers: {
                        'Authorization': `Bearer ${window.CHRONOS_CONFIG.API_KEY}`
                    }
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const event = await response.json();

                // Format dates for display
                const startDate = new Date(event.start_time);
                const endDate = new Date(event.end_time);
                const formatDate = (date) => date.toLocaleDateString('de-DE', {
                    weekday: 'long', year: 'numeric', month: 'long', day: 'numeric'
                });
                const formatTime = (date) => date.toLocaleTimeString('de-DE', {
                    hour: '2-digit', minute: '2-digit'
                });

                showModal('event-details-modal', 'Event Details', `
                    <div style="display: flex; flex-direction: column; gap: var(--space-4);">
                        <div class="event-detail-header">
                            <h3 style="margin: 0; color: var(--primary-600);">${event.summary || 'Unbenanntes Event'}</h3>
                            <div style="display: flex; gap: var(--space-2); margin-top: var(--space-2);">
                                <span class="priority-badge priority-${event.priority || 'medium'}">${(event.priority || 'medium').toUpperCase()}</span>
                                <span class="status-badge">${event.status || 'Geplant'}</span>
                            </div>
                        </div>

                        <div class="event-time-info" style="background: var(--neutral-50); padding: var(--space-4); border-radius: var(--radius-md);">
                            <div style="display: grid; grid-template-columns: auto 1fr; gap: var(--space-3); align-items: center;">
                                <span style="font-weight: var(--font-weight-medium);">üìÖ Datum:</span>
                                <span>${formatDate(startDate)}</span>
                                <span style="font-weight: var(--font-weight-medium);">‚è∞ Zeit:</span>
                                <span>${formatTime(startDate)} - ${formatTime(endDate)}</span>
                                ${event.location ? `<span style="font-weight: var(--font-weight-medium);">üìç Ort:</span><span>${event.location}</span>` : ''}
                            </div>
                        </div>

                        ${event.description ? `
                            <div class="event-description">
                                <h4 style="margin: 0 0 var(--space-2) 0;">Beschreibung:</h4>
                                <p style="margin: 0; line-height: var(--line-height-base); color: var(--text-secondary);">${event.description}</p>
                            </div>
                        ` : ''}

                        <div class="event-metadata" style="font-size: var(--font-size-sm); color: var(--text-muted); border-top: 1px solid var(--border-subtle); padding-top: var(--space-3);">
                            <div>Event-ID: ${eventId}</div>
                            ${event.created ? `<div>Erstellt: ${new Date(event.created).toLocaleString('de-DE')}</div>` : ''}
                            ${event.updated ? `<div>Aktualisiert: ${new Date(event.updated).toLocaleString('de-DE')}</div>` : ''}
                        </div>
                    </div>
                `, `
                    <button class="btn btn-secondary" onclick="closeModal()">Schlie√üen</button>
                    <button class="btn btn-primary" onclick="editEvent('${eventId}')">Bearbeiten</button>
                    <button class="btn btn-danger" onclick="deleteEvent('${eventId}')">L√∂schen</button>
                `);

            } catch (error) {
                console.error('Error loading event details:', error);
                showToast('Fehler', 'Event-Details konnten nicht geladen werden: ' + error.message, 'error');
            }
        }

        // Calendar Navigation State
        let currentCalendarDate = new Date();
        let currentCalendarView = 'month'; // month, week, day

        // Calendar Navigation Functions
        function refreshCalendar() {
            loadCalendarEvents();
        }

        function navigateCalendar(direction) {
            if (direction === 'prev') {
                if (currentCalendarView === 'month') {
                    currentCalendarDate.setMonth(currentCalendarDate.getMonth() - 1);
                } else if (currentCalendarView === 'week') {
                    currentCalendarDate.setDate(currentCalendarDate.getDate() - 7);
                } else if (currentCalendarView === 'day') {
                    currentCalendarDate.setDate(currentCalendarDate.getDate() - 1);
                }
            } else if (direction === 'next') {
                if (currentCalendarView === 'month') {
                    currentCalendarDate.setMonth(currentCalendarDate.getMonth() + 1);
                } else if (currentCalendarView === 'week') {
                    currentCalendarDate.setDate(currentCalendarDate.getDate() + 7);
                } else if (currentCalendarView === 'day') {
                    currentCalendarDate.setDate(currentCalendarDate.getDate() + 1);
                }
            }
            updateCalendarDisplay();
            loadCalendarEvents();
        }

        function goToToday() {
            currentCalendarDate = new Date();
            updateCalendarDisplay();
            loadCalendarEvents();
        }

        function switchView(view) {
            if (['month', 'week', 'day'].includes(view)) {
                currentCalendarView = view;
                updateCalendarDisplay();
                loadCalendarEvents();

                // Update active button state
                document.querySelectorAll('.view-button').forEach(btn => {
                    btn.classList.remove('active');
                });
                document.querySelector(`[data-view="${view}"]`)?.classList.add('active');
            }
        }

        function updateCalendarDisplay() {
            const titleElement = document.querySelector('.calendar-title');
            if (titleElement) {
                const options = {
                    year: 'numeric',
                    month: 'long'
                };
                if (currentCalendarView === 'week') {
                    const weekStart = new Date(currentCalendarDate);
                    weekStart.setDate(currentCalendarDate.getDate() - currentCalendarDate.getDay());
                    const weekEnd = new Date(weekStart);
                    weekEnd.setDate(weekStart.getDate() + 6);
                    titleElement.textContent = `${weekStart.toLocaleDateString('de-DE')} - ${weekEnd.toLocaleDateString('de-DE')}`;
                } else if (currentCalendarView === 'day') {
                    titleElement.textContent = currentCalendarDate.toLocaleDateString('de-DE', {
                        weekday: 'long',
                        year: 'numeric',
                        month: 'long',
                        day: 'numeric'
                    });
                } else {
                    titleElement.textContent = currentCalendarDate.toLocaleDateString('de-DE', options);
                }
            }
        }

        async function loadCalendarEvents() {
            try {
                const startDate = getViewStartDate();
                const endDate = getViewEndDate();

                const response = await fetch(`/api/v1/events?start=${startDate}&end=${endDate}`, {
                    headers: {
                        'Authorization': `Bearer ${window.CHRONOS_CONFIG.API_KEY}`
                    }
                });

                if (response.ok) {
                    const events = await response.json();
                    renderCalendarEvents(events);
                } else {
                    console.error('Failed to load calendar events:', response.status);
                }
            } catch (error) {
                console.error('Error loading calendar events:', error);
            }
        }

        function getViewStartDate() {
            const date = new Date(currentCalendarDate);
            if (currentCalendarView === 'month') {
                date.setDate(1);
            } else if (currentCalendarView === 'week') {
                date.setDate(date.getDate() - date.getDay());
            }
            return date.toISOString().split('T')[0];
        }

        function getViewEndDate() {
            const date = new Date(currentCalendarDate);
            if (currentCalendarView === 'month') {
                date.setMonth(date.getMonth() + 1);
                date.setDate(0);
            } else if (currentCalendarView === 'week') {
                date.setDate(date.getDate() - date.getDay() + 6);
            }
            return date.toISOString().split('T')[0];
        }

        function renderCalendarEvents(events) {
            const calendarContainer = document.querySelector('.calendar-events');
            if (!calendarContainer) return;

            calendarContainer.innerHTML = '';

            events.forEach(event => {
                const eventElement = document.createElement('div');
                eventElement.className = 'calendar-event';
                eventElement.innerHTML = `
                    <div class="event-time">${new Date(event.start_time).toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' })}</div>
                    <div class="event-title">${event.summary}</div>
                `;
                eventElement.onclick = () => viewEventDetails(event.id);
                calendarContainer.appendChild(eventElement);
            });
        }

        function viewAllDayEvents() {
            const startDate = getViewStartDate();
            const endDate = getViewEndDate();

            fetch(`/api/v1/events?start=${startDate}&end=${endDate}&all_day=true`, {
                headers: {
                    'Authorization': `Bearer ${window.CHRONOS_CONFIG.API_KEY}`
                }
            })
            .then(response => response.json())
            .then(events => {
                const allDayEvents = events.filter(event => {
                    const start = new Date(event.start_time);
                    const end = new Date(event.end_time);
                    return (end - start) >= 24 * 60 * 60 * 1000; // 24 hours or more
                });

                showModal('all-day-events', 'Ganztages-Events', `
                    <div class="all-day-events-list">
                        ${allDayEvents.map(event => `
                            <div class="all-day-event" onclick="viewEventDetails('${event.id}')">
                                <div class="event-title">${event.summary}</div>
                                <div class="event-date">${new Date(event.start_time).toLocaleDateString('de-DE')}</div>
                            </div>
                        `).join('')}
                    </div>
                `, '<button class="btn btn-secondary" onclick="closeModal()">Schlie√üen</button>');
            })
            .catch(error => {
                console.error('Error loading all-day events:', error);
            });
        }

        // Analytics Functions
        async function refreshAnalytics() {
            try {
                showToast('Info', 'Analytics werden aktualisiert...', 'info');

                // Refresh dashboard data via existing endpoint
                const response = await fetch('/api/v1/dashboard-data', {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${window.CHRONOS_CONFIG.API_KEY}`,
                        'Content-Type': 'application/json'
                    }
                });

                if (!response.ok) {
                    throw new Error(`Dashboard API error: ${response.status}`);
                }

                const dashboardData = await response.json();

                // Update analytics widgets with new data
                if (dashboardData.productivity_metrics) {
                    updateProductivityMetrics(dashboardData.productivity_metrics);
                }

                if (dashboardData.priority_distribution) {
                    updatePriorityDistribution(dashboardData.priority_distribution);
                }

                if (dashboardData.time_distribution) {
                    updateTimeDistribution(dashboardData.time_distribution);
                }

                if (dashboardData.recommendations) {
                    updateRecommendations(dashboardData.recommendations);
                }

                showToast('Erfolg', 'Analytics erfolgreich aktualisiert!', 'success');

            } catch (error) {
                console.error('Error refreshing analytics:', error);
                showToast('Fehler', 'Analytics-Update fehlgeschlagen: ' + error.message, 'error');
            }
        }

        function updateProductivityMetrics(metrics) {
            // Update productivity metrics display
            const completionElement = document.querySelector('.completion-rate');
            if (completionElement && metrics.completion_rate !== undefined) {
                completionElement.textContent = (metrics.completion_rate * 100).toFixed(1) + '%';
            }

            const eventsElement = document.querySelector('.total-events');
            if (eventsElement && metrics.total_events !== undefined) {
                eventsElement.textContent = metrics.total_events.toLocaleString();
            }

            const hoursElement = document.querySelector('.total-hours');
            if (hoursElement && metrics.total_hours !== undefined) {
                hoursElement.textContent = metrics.total_hours.toFixed(1) + 'h';
            }
        }

        function updatePriorityDistribution(distribution) {
            // Update priority distribution display
            Object.entries(distribution).forEach(([priority, count]) => {
                const element = document.querySelector(`.priority-${priority.toLowerCase()}`);
                if (element) {
                    element.textContent = count.toLocaleString();
                }
            });
        }

        function updateTimeDistribution(timeData) {
            try {
                // Update time distribution chart with real visualization
                const chartElement = document.querySelector('.time-chart, [data-chart="time-distribution"]');
                if (!chartElement) return;

                // Convert hour data to chart bars
                const maxValue = Math.max(...Object.values(timeData));
                const hours = Object.keys(timeData).sort((a, b) => parseInt(a) - parseInt(b));

                // Create time distribution chart HTML
                const chartHTML = `
                    <div class="time-distribution-chart" style="display: flex; align-items: end; gap: 2px; height: 120px; padding: 10px; overflow-x: auto;">
                        ${hours.map(hour => {
                            const value = timeData[hour] || 0;
                            const percentage = maxValue > 0 ? (value / maxValue) * 100 : 0;
                            const displayHour = parseInt(hour);
                            const timeLabel = displayHour === 0 ? '00' : displayHour < 10 ? `0${displayHour}` : displayHour.toString();

                            return `
                                <div class="time-bar-container" style="display: flex; flex-direction: column; align-items: center; min-width: 12px;">
                                    <div class="time-bar" style="
                                        background: var(--primary-500);
                                        width: 12px;
                                        height: ${Math.max(percentage, 2)}%;
                                        border-radius: 2px 2px 0 0;
                                        opacity: ${percentage > 0 ? 1 : 0.3};
                                        transition: height 0.3s ease;
                                        margin-bottom: 2px;
                                    " title="${timeLabel}:00 - ${value.toFixed(1)}h"></div>
                                    ${(displayHour % 3 === 0) ? `<span style="font-size: 10px; color: var(--text-muted);">${timeLabel}</span>` : ''}
                                </div>
                            `;
                        }).join('')}
                    </div>
                `;

                chartElement.innerHTML = chartHTML;

                // Update peak hours display
                const peakHour = hours.reduce((max, hour) =>
                    timeData[hour] > timeData[max] ? hour : max, hours[0]);

                const peakElement = document.querySelector('.peak-hours');
                if (peakElement && timeData[peakHour] > 0) {
                    const peakTime = parseInt(peakHour);
                    const peakLabel = peakTime === 0 ? '00:00' :
                                     peakTime < 10 ? `0${peakTime}:00` : `${peakTime}:00`;
                    peakElement.textContent = `${peakLabel} (${timeData[peakHour].toFixed(1)}h)`;
                }

            } catch (error) {
                console.error('Error updating time distribution:', error);
            }
        }

        function updateRecommendations(recommendations) {
            // Update recommendations list
            const recContainer = document.querySelector('.recommendations-container');
            if (recContainer && recommendations.length > 0) {
                const recHtml = recommendations.map(rec => `
                    <div class="recommendation ${rec.priority}" style="margin-bottom: var(--space-2); padding: var(--space-3); border-radius: var(--radius-md); background: var(--${rec.priority === 'high' ? 'warning' : rec.priority === 'medium' ? 'info' : 'success'}-50);">
                        <span class="rec-type" style="font-weight: var(--font-weight-medium);">${rec.type}:</span>
                        <span class="rec-message">${rec.message}</span>
                    </div>
                `).join('');
                recContainer.innerHTML = recHtml;
            }
        }

        async function exportAnalytics() {
            try {
                showToast('Info', 'Exportiere Analytics...', 'info');

                // Get real analytics data from backend
                const response = await fetch('/api/v1/analytics/productivity?days=30', {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${window.CHRONOS_CONFIG.API_KEY}`,
                        'Content-Type': 'application/json'
                    }
                });

                if (!response.ok) {
                    throw new Error(`Analytics API error: ${response.status}`);
                }

                const analyticsData = await response.json();

                // Create comprehensive export data
                const exportData = {
                    timestamp: new Date().toISOString(),
                    period: {
                        start: analyticsData.period_start,
                        end: analyticsData.period_end,
                        days: 30
                    },
                    metrics: analyticsData.metrics,
                    export_metadata: {
                        chronos_version: '2.2.0',
                        format_version: '1.0',
                        exported_by: 'Chronos Analytics Engine'
                    }
                };

                // Create and download file
                const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `chronos-analytics-${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                showToast('Erfolg', `Analytics-Daten (${analyticsData.metrics.total_events} Events) exportiert!`, 'success');

            } catch (error) {
                console.error('Error exporting analytics:', error);
                showToast('Fehler', 'Analytics-Export fehlgeschlagen: ' + error.message, 'error');
            }
        }

        async function setTimeRange(range) {
            try {
                showToast('Info', `Zeitbereich wird auf ${range} gesetzt...`, 'info');

                // Map range to days for API call
                const rangeDaysMap = {
                    '7d': 7,
                    '30d': 30,
                    '90d': 90,
                    '365d': 365,
                    'week': 7,
                    'month': 30,
                    'quarter': 90,
                    'year': 365
                };

                const days = rangeDaysMap[range] || 30;

                // Get analytics data for the specified range
                const response = await fetch(`/api/v1/analytics/productivity?days=${days}`, {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${window.CHRONOS_CONFIG.API_KEY}`,
                        'Content-Type': 'application/json'
                    }
                });

                if (!response.ok) {
                    throw new Error(`Analytics API error: ${response.status}`);
                }

                const analyticsData = await response.json();

                // Update analytics displays with new time range
                if (analyticsData.metrics) {
                    updateProductivityMetrics(analyticsData.metrics);
                }

                // Update range display indicators
                document.querySelectorAll('.time-range-button').forEach(btn => {
                    btn.classList.remove('active');
                });
                document.querySelector(`[data-range="${range}"]`)?.classList.add('active');

                // Update chart period labels
                const periodLabel = document.querySelector('.analytics-period-label');
                if (periodLabel) {
                    const periodText = range === '7d' ? 'Letzte 7 Tage' :
                                     range === '30d' ? 'Letzte 30 Tage' :
                                     range === '90d' ? 'Letzte 90 Tage' :
                                     range === '365d' ? 'Letztes Jahr' : `Letzte ${days} Tage`;
                    periodLabel.textContent = periodText;
                }

                showToast('Erfolg', `Analytics f√ºr ${range.replace('d', ' Tage')} aktualisiert!`, 'success');

            } catch (error) {
                console.error('Error setting time range:', error);
                showToast('Fehler', 'Zeitbereich konnte nicht gesetzt werden: ' + error.message, 'error');
            }
        }

        function switchChartType(chart, type) {
            try {
                showToast('Info', `Chart-Typ wird auf ${type} ge√§ndert...`, 'info');

                // Get the chart container
                const chartContainer = document.querySelector(`#${chart}-chart, .${chart}-chart, [data-chart="${chart}"]`);
                if (!chartContainer) {
                    throw new Error(`Chart container f√ºr ${chart} nicht gefunden`);
                }

                // Update chart type attribute and visual representation
                chartContainer.setAttribute('data-chart-type', type);

                // Switch visualization based on type
                switch (type) {
                    case 'bar':
                        renderBarChart(chartContainer, chart);
                        break;
                    case 'line':
                        renderLineChart(chartContainer, chart);
                        break;
                    case 'pie':
                        renderPieChart(chartContainer, chart);
                        break;
                    case 'area':
                        renderAreaChart(chartContainer, chart);
                        break;
                    default:
                        renderBarChart(chartContainer, chart); // Default to bar chart
                }

                // Update chart type selector buttons
                const typeButtons = document.querySelectorAll(`[data-chart="${chart}"] .chart-type-button`);
                typeButtons.forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.getAttribute('data-type') === type) {
                        btn.classList.add('active');
                    }
                });

                // Save user preference for this chart type
                if (window.localStorage) {
                    const chartPrefs = JSON.parse(localStorage.getItem('chronos-chart-preferences') || '{}');
                    chartPrefs[chart] = type;
                    localStorage.setItem('chronos-chart-preferences', JSON.stringify(chartPrefs));
                }

                showToast('Erfolg', `${chart}-Chart auf ${type} umgestellt!`, 'success');

            } catch (error) {
                console.error('Error switching chart type:', error);
                showToast('Fehler', 'Chart-Typ konnte nicht ge√§ndert werden: ' + error.message, 'error');
            }
        }

        function renderBarChart(container, chartName) {
            // Simple bar chart representation
            container.innerHTML = `
                <div class="chart-placeholder bar-chart" style="display: flex; align-items: end; gap: 4px; height: 120px; padding: 10px;">
                    <div class="chart-bar" style="background: var(--primary-500); width: 20px; height: 60%; border-radius: 2px 2px 0 0;"></div>
                    <div class="chart-bar" style="background: var(--primary-500); width: 20px; height: 80%; border-radius: 2px 2px 0 0;"></div>
                    <div class="chart-bar" style="background: var(--primary-500); width: 20px; height: 70%; border-radius: 2px 2px 0 0;"></div>
                    <div class="chart-bar" style="background: var(--primary-500); width: 20px; height: 90%; border-radius: 2px 2px 0 0;"></div>
                    <div class="chart-bar" style="background: var(--primary-500); width: 20px; height: 85%; border-radius: 2px 2px 0 0;"></div>
                </div>
            `;
        }

        function renderLineChart(container, chartName) {
            // Simple line chart representation
            container.innerHTML = `
                <div class="chart-placeholder line-chart" style="height: 120px; padding: 10px; position: relative;">
                    <svg width="100%" height="100%" style="overflow: visible;">
                        <polyline fill="none" stroke="var(--primary-500)" stroke-width="2"
                                  points="10,80 30,50 50,60 70,30 90,40"
                                  style="vector-effect: non-scaling-stroke;"/>
                        <circle cx="10" cy="80" r="3" fill="var(--primary-500)"/>
                        <circle cx="30" cy="50" r="3" fill="var(--primary-500)"/>
                        <circle cx="50" cy="60" r="3" fill="var(--primary-500)"/>
                        <circle cx="70" cy="30" r="3" fill="var(--primary-500)"/>
                        <circle cx="90" cy="40" r="3" fill="var(--primary-500)"/>
                    </svg>
                </div>
            `;
        }

        function renderPieChart(container, chartName) {
            // Simple pie chart representation
            container.innerHTML = `
                <div class="chart-placeholder pie-chart" style="height: 120px; padding: 10px; display: flex; justify-content: center; align-items: center;">
                    <div style="width: 80px; height: 80px; border-radius: 50%; background: conic-gradient(
                        var(--primary-500) 0deg 120deg,
                        var(--primary-400) 120deg 240deg,
                        var(--primary-300) 240deg 360deg
                    );"></div>
                </div>
            `;
        }

        function renderAreaChart(container, chartName) {
            // Simple area chart representation
            container.innerHTML = `
                <div class="chart-placeholder area-chart" style="height: 120px; padding: 10px; position: relative;">
                    <svg width="100%" height="100%" style="overflow: visible;">
                        <defs>
                            <linearGradient id="areaGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                                <stop offset="0%" style="stop-color:var(--primary-500);stop-opacity:0.6" />
                                <stop offset="100%" style="stop-color:var(--primary-500);stop-opacity:0.1" />
                            </linearGradient>
                        </defs>
                        <polygon fill="url(#areaGradient)" stroke="var(--primary-500)" stroke-width="2"
                                 points="10,100 10,80 30,50 50,60 70,30 90,40 90,100" />
                    </svg>
                </div>
            `;
        }

        async function applyInsight(id) {
            try {
                showToast('Info', `AI-Insight ${id} wird angewendet...`, 'info');

                // Apply the insight via backend API
                const response = await fetch('/api/v1/ai/apply-insight', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${window.CHRONOS_CONFIG.API_KEY}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        insight_id: id,
                        action: 'apply'
                    })
                });

                if (!response.ok) {
                    throw new Error(`API error: ${response.status}`);
                }

                const result = await response.json();

                if (result.success) {
                    // Remove the insight from UI
                    const insightElement = document.querySelector(`[data-insight-id="${id}"]`);
                    if (insightElement) {
                        insightElement.style.transition = 'opacity 0.3s ease';
                        insightElement.style.opacity = '0';
                        setTimeout(() => insightElement.remove(), 300);
                    }

                    // Refresh relevant data if needed
                    if (result.requires_refresh) {
                        await refreshAnalytics();
                    }

                    showToast('Erfolg', `AI-Insight angewendet: ${result.message || 'Optimierung aktiviert'}`, 'success');
                } else {
                    throw new Error(result.message || 'Insight konnte nicht angewendet werden');
                }

            } catch (error) {
                console.error('Error applying insight:', error);
                showToast('Fehler', `Insight konnte nicht angewendet werden: ${error.message}`, 'error');
            }
        }

        async function dismissInsight(id) {
            try {
                showToast('Info', `Insight ${id} wird ausgeblendet...`, 'info');

                // Dismiss the insight via backend API
                const response = await fetch('/api/v1/ai/dismiss-insight', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${window.CHRONOS_CONFIG.API_KEY}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        insight_id: id,
                        action: 'dismiss'
                    })
                });

                if (!response.ok) {
                    throw new Error(`API error: ${response.status}`);
                }

                const result = await response.json();

                if (result.success) {
                    // Remove the insight from UI with animation
                    const insightElement = document.querySelector(`[data-insight-id="${id}"]`);
                    if (insightElement) {
                        insightElement.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
                        insightElement.style.opacity = '0';
                        insightElement.style.transform = 'translateX(100%)';
                        setTimeout(() => insightElement.remove(), 300);
                    }

                    showToast('Info', 'Insight ausgeblendet', 'info');
                } else {
                    throw new Error(result.message || 'Insight konnte nicht ausgeblendet werden');
                }

            } catch (error) {
                console.error('Error dismissing insight:', error);
                showToast('Fehler', `Insight konnte nicht ausgeblendet werden: ${error.message}`, 'error');
            }
        }

        async function generateReport() {
            try {
                showToast('Info', 'Generiere umfassenden Analytics-Report...', 'info');

                // Get comprehensive report from backend
                const response = await fetch('/api/v1/analytics/report', {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${window.CHRONOS_CONFIG.API_KEY}`,
                        'Content-Type': 'application/json'
                    }
                });

                if (!response.ok) {
                    throw new Error(`Report API error: ${response.status}`);
                }

                const reportData = await response.json();

                if (!reportData.success) {
                    throw new Error('Report generation failed on server');
                }

                // Show report in modal
                const report = reportData.report;
                const reportHtml = `
                    <div style="display: flex; flex-direction: column; gap: var(--space-4); max-height: 70vh; overflow-y: auto;">
                        <div class="report-header" style="text-align: center; padding: var(--space-4); background: var(--primary-50); border-radius: var(--radius-md);">
                            <h3 style="margin: 0; color: var(--primary-700);">üìä Chronos Analytics Report</h3>
                            <p style="margin: var(--space-2) 0 0 0; color: var(--text-secondary);">
                                Generiert am: ${new Date(reportData.generated_at).toLocaleString('de-DE')}
                            </p>
                        </div>

                        <div class="report-metrics" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: var(--space-3);">
                            ${Object.entries(report.summary || {}).map(([key, value]) => `
                                <div style="padding: var(--space-3); background: var(--neutral-50); border-radius: var(--radius-md); text-align: center;">
                                    <div style="font-size: var(--font-size-lg); font-weight: var(--font-weight-semibold); color: var(--primary-600);">
                                        ${typeof value === 'number' ? (value < 1 ? (value * 100).toFixed(1) + '%' : value.toLocaleString()) : value}
                                    </div>
                                    <div style="font-size: var(--font-size-sm); color: var(--text-secondary); text-transform: capitalize;">
                                        ${key.replace(/_/g, ' ')}
                                    </div>
                                </div>
                            `).join('')}
                        </div>

                        <div class="report-insights" style="background: var(--success-50); padding: var(--space-4); border-radius: var(--radius-md);">
                            <h4 style="margin: 0 0 var(--space-3) 0; color: var(--success-700);">üí° Wichtige Erkenntnisse</h4>
                            ${report.insights ? `
                                <ul style="margin: 0; padding-left: var(--space-5);">
                                    ${report.insights.map(insight => `<li style="margin-bottom: var(--space-2); color: var(--text-primary);">${insight}</li>`).join('')}
                                </ul>
                            ` : '<p style="margin: 0; color: var(--text-secondary);">Keine besonderen Erkenntnisse verf√ºgbar.</p>'}
                        </div>

                        <div class="report-recommendations" style="background: var(--warning-50); padding: var(--space-4); border-radius: var(--radius-md);">
                            <h4 style="margin: 0 0 var(--space-3) 0; color: var(--warning-700);">üéØ Empfehlungen</h4>
                            ${report.recommendations ? `
                                <ul style="margin: 0; padding-left: var(--space-5);">
                                    ${report.recommendations.map(rec => `<li style="margin-bottom: var(--space-2); color: var(--text-primary);">${rec}</li>`).join('')}
                                </ul>
                            ` : '<p style="margin: 0; color: var(--text-secondary);">Keine Empfehlungen verf√ºgbar.</p>'}
                        </div>
                    </div>
                `;

                showModal('analytics-report-modal', 'üìä Analytics Report', reportHtml, `
                    <button class="btn btn-secondary" onclick="closeModal()">Schlie√üen</button>
                    <button class="btn btn-primary" onclick="downloadReportPDF()">Als PDF herunterladen</button>
                `);

                showToast('Erfolg', 'Analytics-Report erfolgreich generiert!', 'success');

            } catch (error) {
                console.error('Error generating report:', error);
                showToast('Fehler', 'Report-Generierung fehlgeschlagen: ' + error.message, 'error');
            }
        }

        async function downloadReportPDF() {
            try {
                showToast('Info', 'PDF-Report wird generiert...', 'info');

                // Get comprehensive report data from backend
                const response = await fetch('/api/v1/analytics/report?format=pdf', {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${window.CHRONOS_CONFIG.API_KEY}`,
                        'Content-Type': 'application/json'
                    }
                });

                if (!response.ok) {
                    throw new Error(`PDF generation API error: ${response.status}`);
                }

                const contentType = response.headers.get('content-type');

                if (contentType && contentType.includes('application/pdf')) {
                    // Backend provided a real PDF
                    const blob = await response.blob();
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `chronos-analytics-report-${new Date().toISOString().split('T')[0]}.pdf`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);

                    showToast('Erfolg', 'PDF-Report erfolgreich heruntergeladen!', 'success');
                } else {
                    // Fallback: Create HTML-based printable version
                    const result = await response.json();
                    const report = result.report;

                    const printableHTML = `
                        <!DOCTYPE html>
                        <html>
                        <head>
                            <title>Chronos Analytics Report</title>
                            <style>
                                body { font-family: Arial, sans-serif; margin: 20px; line-height: 1.6; }
                                .header { text-align: center; border-bottom: 2px solid #333; padding-bottom: 20px; margin-bottom: 30px; }
                                .metrics { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin: 30px 0; }
                                .metric { border: 1px solid #ddd; padding: 15px; border-radius: 8px; text-align: center; }
                                .metric-value { font-size: 24px; font-weight: bold; color: #2563eb; }
                                .metric-label { color: #666; text-transform: capitalize; }
                                .section { margin: 30px 0; }
                                .section h3 { color: #1f2937; border-bottom: 1px solid #e5e7eb; padding-bottom: 10px; }
                                ul { padding-left: 20px; }
                                li { margin-bottom: 8px; }
                                .footer { margin-top: 50px; text-align: center; color: #666; font-size: 12px; }
                                @media print { body { margin: 0; } }
                            </style>
                        </head>
                        <body>
                            <div class="header">
                                <h1>üìä Chronos Analytics Report</h1>
                                <p>Generiert am: ${new Date().toLocaleString('de-DE')}</p>
                            </div>

                            <div class="metrics">
                                ${Object.entries(report.summary || {}).map(([key, value]) => `
                                    <div class="metric">
                                        <div class="metric-value">${typeof value === 'number' ? (value < 1 ? (value * 100).toFixed(1) + '%' : value.toLocaleString()) : value}</div>
                                        <div class="metric-label">${key.replace(/_/g, ' ')}</div>
                                    </div>
                                `).join('')}
                            </div>

                            <div class="section">
                                <h3>üí° Wichtige Erkenntnisse</h3>
                                ${report.insights ? `<ul>${report.insights.map(insight => `<li>${insight}</li>`).join('')}</ul>` : '<p>Keine besonderen Erkenntnisse verf√ºgbar.</p>'}
                            </div>

                            <div class="section">
                                <h3>üéØ Empfehlungen</h3>
                                ${report.recommendations ? `<ul>${report.recommendations.map(rec => `<li>${rec}</li>`).join('')}</ul>` : '<p>Keine Empfehlungen verf√ºgbar.</p>'}
                            </div>

                            <div class="footer">
                                <p>Erstellt mit Chronos Engine v2.2.0 | ${new Date().toLocaleDateString('de-DE')}</p>
                            </div>
                        </body>
                        </html>
                    `;

                    // Create printable HTML file
                    const htmlBlob = new Blob([printableHTML], { type: 'text/html' });
                    const htmlUrl = URL.createObjectURL(htmlBlob);

                    // Open in new window for printing
                    const printWindow = window.open(htmlUrl, '_blank');
                    if (printWindow) {
                        printWindow.onload = () => {
                            setTimeout(() => {
                                printWindow.print();
                                URL.revokeObjectURL(htmlUrl);
                            }, 500);
                        };
                    }

                    showToast('Erfolg', 'Report-Druckansicht ge√∂ffnet!', 'success');
                }

            } catch (error) {
                console.error('Error downloading PDF report:', error);
                showToast('Fehler', `PDF-Download fehlgeschlagen: ${error.message}`, 'error');
            }
        }

        // Template Management Functions
        function createNewTemplate() {
            showModal('template-modal', 'Neue Vorlage erstellen', `
                <form id="templateForm">
                    <div style="display: flex; flex-direction: column; gap: var(--space-4);">
                        <div>
                            <label for="templateName" style="display: block; margin-bottom: var(--space-2); font-weight: var(--font-weight-medium);">Name der Vorlage</label>
                            <input type="text" id="templateName" name="name" style="width: 100%; padding: var(--space-3); border: 1px solid var(--border-base); border-radius: var(--radius-md);" required>
                        </div>
                        <div>
                            <label for="templateDescription" style="display: block; margin-bottom: var(--space-2); font-weight: var(--font-weight-medium);">Beschreibung</label>
                            <textarea id="templateDescription" name="description" rows="3" style="width: 100%; padding: var(--space-3); border: 1px solid var(--border-base); border-radius: var(--radius-md);"></textarea>
                        </div>
                        <div>
                            <label for="templateCategory" style="display: block; margin-bottom: var(--space-2); font-weight: var(--font-weight-medium);">Kategorie</label>
                            <select id="templateCategory" name="category" style="width: 100%; padding: var(--space-3); border: 1px solid var(--border-base); border-radius: var(--radius-md);">
                                <option value="meeting">Meeting</option>
                                <option value="task">Aufgabe</option>
                                <option value="appointment">Termin</option>
                                <option value="reminder">Erinnerung</option>
                            </select>
                        </div>
                    </div>
                </form>
            `, '<button class="btn btn-secondary" onclick="closeModal()">Abbrechen</button><button class="btn btn-primary" onclick="saveTemplate()">Vorlage speichern</button>');
        }

        async function saveTemplate() {
            const form = document.getElementById('templateForm');
            if (form && form.checkValidity()) {
                const formData = new FormData(form);
                const templateData = {
                    name: formData.get('name'),
                    description: formData.get('description'),
                    category: formData.get('category'),
                    template_data: {
                        summary: formData.get('name'),
                        description: formData.get('description'),
                        duration_minutes: 60,
                        location: '',
                        priority: 'MEDIUM'
                    },
                    default_duration_minutes: 60,
                    default_priority: 'MEDIUM',
                    is_active: true
                };

                try {
                    const response = await fetch('/api/v1/templates', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${window.CHRONOS_CONFIG.API_KEY}`
                        },
                        body: JSON.stringify(templateData)
                    });

                    if (response.ok) {
                        const result = await response.json();
                        closeModal();
                        showToast('Erfolg', 'Vorlage erfolgreich gespeichert!', 'success');
                        loadTemplates();
                    } else {
                        const error = await response.json();
                        showToast('Fehler', `Fehler beim Speichern: ${error.detail}`, 'error');
                    }
                } catch (error) {
                    showToast('Fehler', `Netzwerkfehler: ${error.message}`, 'error');
                }
            } else {
                showToast('Fehler', 'Bitte f√ºllen Sie alle Pflichtfelder aus.', 'error');
            }
        }

        async function editTemplate(id) {
            try {
                const response = await fetch(`/api/v1/templates/${id}`, {
                    headers: {
                        'Authorization': `Bearer ${window.CHRONOS_CONFIG.API_KEY}`
                    }
                });

                if (response.ok) {
                    const template = await response.json();

                    showModal('edit-template-modal', 'Vorlage bearbeiten', `
                        <form id="editTemplateForm">
                            <input type="hidden" name="templateId" value="${id}">
                            <div style="display: flex; flex-direction: column; gap: var(--space-4);">
                                <div>
                                    <label for="editTemplateName" style="display: block; margin-bottom: var(--space-2); font-weight: var(--font-weight-medium);">Name der Vorlage</label>
                                    <input type="text" id="editTemplateName" name="name" value="${template.name}" style="width: 100%; padding: var(--space-3); border: 1px solid var(--border-base); border-radius: var(--radius-md);" required>
                                </div>
                                <div>
                                    <label for="editTemplateDescription" style="display: block; margin-bottom: var(--space-2); font-weight: var(--font-weight-medium);">Beschreibung</label>
                                    <textarea id="editTemplateDescription" name="description" rows="3" style="width: 100%; padding: var(--space-3); border: 1px solid var(--border-base); border-radius: var(--radius-md);">${template.description || ''}</textarea>
                                </div>
                                <div>
                                    <label for="editTemplateCategory" style="display: block; margin-bottom: var(--space-2); font-weight: var(--font-weight-medium);">Kategorie</label>
                                    <select id="editTemplateCategory" name="category" style="width: 100%; padding: var(--space-3); border: 1px solid var(--border-base); border-radius: var(--radius-md);">
                                        <option value="meeting" ${template.category === 'meeting' ? 'selected' : ''}>Meeting</option>
                                        <option value="task" ${template.category === 'task' ? 'selected' : ''}>Aufgabe</option>
                                        <option value="appointment" ${template.category === 'appointment' ? 'selected' : ''}>Termin</option>
                                        <option value="reminder" ${template.category === 'reminder' ? 'selected' : ''}>Erinnerung</option>
                                    </select>
                                </div>
                            </div>
                        </form>
                    `, '<button class="btn btn-secondary" onclick="closeModal()">Abbrechen</button><button class="btn btn-primary" onclick="updateTemplate()">Aktualisieren</button>');
                } else {
                    showToast('Fehler', 'Vorlage konnte nicht geladen werden.', 'error');
                }
            } catch (error) {
                showToast('Fehler', `Fehler beim Laden: ${error.message}`, 'error');
            }
        }

        async function updateTemplate() {
            const form = document.getElementById('editTemplateForm');
            if (form && form.checkValidity()) {
                const formData = new FormData(form);
                const templateId = formData.get('templateId');
                const templateData = {
                    name: formData.get('name'),
                    description: formData.get('description'),
                    category: formData.get('category')
                };

                try {
                    const response = await fetch(`/api/v1/templates/${templateId}`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${window.CHRONOS_CONFIG.API_KEY}`
                        },
                        body: JSON.stringify(templateData)
                    });

                    if (response.ok) {
                        closeModal();
                        showToast('Erfolg', 'Vorlage erfolgreich aktualisiert!', 'success');
                        loadTemplates();
                    } else {
                        const error = await response.json();
                        showToast('Fehler', `Fehler beim Aktualisieren: ${error.detail}`, 'error');
                    }
                } catch (error) {
                    showToast('Fehler', `Netzwerkfehler: ${error.message}`, 'error');
                }
            }
        }

        async function useTemplate(id) {
            try {
                const response = await fetch(`/api/v1/templates/${id}`, {
                    headers: {
                        'Authorization': `Bearer ${window.CHRONOS_CONFIG.API_KEY}`
                    }
                });

                if (response.ok) {
                    const template = await response.json();
                    const templateData = template.template_data;

                    showModal('use-template-modal', 'Event aus Vorlage erstellen', `
                        <form id="useTemplateForm">
                            <div style="display: flex; flex-direction: column; gap: var(--space-4);">
                                <div>
                                    <label for="useTemplateTitle" style="display: block; margin-bottom: var(--space-2); font-weight: var(--font-weight-medium);">Titel</label>
                                    <input type="text" id="useTemplateTitle" name="title" value="${templateData.summary || template.name}" style="width: 100%; padding: var(--space-3); border: 1px solid var(--border-base); border-radius: var(--radius-md);" required>
                                </div>
                                <div>
                                    <label for="useTemplateDate" style="display: block; margin-bottom: var(--space-2); font-weight: var(--font-weight-medium);">Datum</label>
                                    <input type="date" id="useTemplateDate" name="date" value="${new Date().toISOString().split('T')[0]}" style="width: 100%; padding: var(--space-3); border: 1px solid var(--border-base); border-radius: var(--radius-md);" required>
                                </div>
                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: var(--space-3);">
                                    <div>
                                        <label for="useTemplateTime" style="display: block; margin-bottom: var(--space-2); font-weight: var(--font-weight-medium);">Startzeit</label>
                                        <input type="time" id="useTemplateTime" name="time" value="09:00" style="width: 100%; padding: var(--space-3); border: 1px solid var(--border-base); border-radius: var(--radius-md);" required>
                                    </div>
                                    <div>
                                        <label for="useTemplateDuration" style="display: block; margin-bottom: var(--space-2); font-weight: var(--font-weight-medium);">Dauer (Min)</label>
                                        <input type="number" id="useTemplateDuration" name="duration" value="${template.default_duration_minutes || 60}" style="width: 100%; padding: var(--space-3); border: 1px solid var(--border-base); border-radius: var(--radius-md);" required>
                                    </div>
                                </div>
                                <div>
                                    <label for="useTemplateDescription" style="display: block; margin-bottom: var(--space-2); font-weight: var(--font-weight-medium);">Beschreibung</label>
                                    <textarea id="useTemplateDescription" name="description" rows="3" style="width: 100%; padding: var(--space-3); border: 1px solid var(--border-base); border-radius: var(--radius-md);">${templateData.description || ''}</textarea>
                                </div>
                                <div>
                                    <label for="useTemplateLocation" style="display: block; margin-bottom: var(--space-2); font-weight: var(--font-weight-medium);">Ort</label>
                                    <input type="text" id="useTemplateLocation" name="location" value="${templateData.location || ''}" style="width: 100%; padding: var(--space-3); border: 1px solid var(--border-base); border-radius: var(--radius-md);">
                                </div>
                            </div>
                        </form>
                    `, '<button class="btn btn-secondary" onclick="closeModal()">Abbrechen</button><button class="btn btn-primary" onclick="createEventFromTemplate()">Event erstellen</button>');
                } else {
                    showToast('Fehler', 'Vorlage konnte nicht geladen werden.', 'error');
                }
            } catch (error) {
                showToast('Fehler', `Fehler beim Laden: ${error.message}`, 'error');
            }
        }

        async function createEventFromTemplate() {
            const form = document.getElementById('useTemplateForm');
            if (form && form.checkValidity()) {
                const formData = new FormData(form);
                const duration = parseInt(formData.get('duration'));
                const startTime = new Date(`${formData.get('date')}T${formData.get('time')}`);
                const endTime = new Date(startTime.getTime() + duration * 60000);

                const eventData = {
                    summary: formData.get('title'),
                    description: formData.get('description'),
                    start_time: startTime.toISOString(),
                    end_time: endTime.toISOString(),
                    location: formData.get('location'),
                    priority: 'medium'
                };

                try {
                    const response = await fetch('/api/v1/events', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${window.CHRONOS_CONFIG.API_KEY}`
                        },
                        body: JSON.stringify(eventData)
                    });

                    if (response.ok) {
                        closeModal();
                        showToast('Erfolg', 'Event aus Vorlage erstellt!', 'success');
                        refreshDashboard();
                    } else {
                        const error = await response.json();
                        showToast('Fehler', `Fehler beim Erstellen: ${error.detail}`, 'error');
                    }
                } catch (error) {
                    showToast('Fehler', `Netzwerkfehler: ${error.message}`, 'error');
                }
            }
        }

        async function deleteTemplate(id) {
            if (confirm('Sind Sie sicher, dass Sie diese Vorlage l√∂schen m√∂chten?')) {
                try {
                    const response = await fetch(`/api/v1/templates/${id}`, {
                        method: 'DELETE',
                        headers: {
                            'Authorization': `Bearer ${window.CHRONOS_CONFIG.API_KEY}`
                        }
                    });

                    if (response.ok) {
                        showToast('Erfolg', 'Vorlage erfolgreich gel√∂scht!', 'success');
                        loadTemplates();
                    } else {
                        const error = await response.json();
                        showToast('Fehler', `Fehler beim L√∂schen: ${error.detail}`, 'error');
                    }
                } catch (error) {
                    showToast('Fehler', `Netzwerkfehler: ${error.message}`, 'error');
                }
            }
        }

        async function loadTemplates() {
            try {
                const response = await fetch('/api/v1/templates', {
                    headers: {
                        'Authorization': `Bearer ${window.CHRONOS_CONFIG.API_KEY}`
                    }
                });

                if (response.ok) {
                    const result = await response.json();
                    renderTemplatesList(result.templates);
                }
            } catch (error) {
                console.error('Error loading templates:', error);
            }
        }

        function renderTemplatesList(templates) {
            const container = document.querySelector('.templates-list');
            if (!container) return;

            if (templates.length === 0) {
                container.innerHTML = '<p>Keine Vorlagen vorhanden.</p>';
                return;
            }

            container.innerHTML = templates.map(template => `
                <div class="template-item">
                    <div class="template-info">
                        <h4>${template.name}</h4>
                        <p>${template.description || ''}</p>
                        <span class="template-category">${template.category}</span>
                    </div>
                    <div class="template-actions">
                        <button class="btn btn-sm btn-primary" onclick="useTemplate('${template.id}')">Verwenden</button>
                        <button class="btn btn-sm btn-secondary" onclick="editTemplate('${template.id}')">Bearbeiten</button>
                        <button class="btn btn-sm btn-danger" onclick="deleteTemplate('${template.id}')">L√∂schen</button>
                    </div>
                </div>
            `).join('');
        }

        // Settings Functions
        async function saveSettings() {
            try {
                showToast('Info', 'Speichere Einstellungen...', 'info');

                // Collect all settings from forms
                const settings = {};
                const forms = document.querySelectorAll('form[data-settings]');

                forms.forEach(form => {
                    const formData = new FormData(form);
                    const category = form.dataset.settings;
                    settings[category] = {};

                    for (let [key, value] of formData.entries()) {
                        settings[category][key] = value;
                    }
                });

                // Save to backend first
                const response = await fetch('/api/v1/settings', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${window.CHRONOS_CONFIG.API_KEY}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        settings: settings,
                        timestamp: new Date().toISOString()
                    })
                });

                if (!response.ok) {
                    throw new Error(`Settings API error: ${response.status}`);
                }

                const result = await response.json();

                if (result.success) {
                    // Save to localStorage as backup
                    localStorage.setItem('chronos_settings', JSON.stringify(settings));
                    localStorage.setItem('chronos_settings_sync', new Date().toISOString());

                    showToast('Erfolg', 'Einstellungen erfolgreich gespeichert!', 'success');

                    // Apply settings immediately if needed
                    if (settings.appearance) {
                        applyTheme();
                    }
                } else {
                    throw new Error(result.message || 'Einstellungen konnten nicht gespeichert werden');
                }

            } catch (error) {
                console.error('Error saving settings:', error);

                // Fallback to localStorage only
                try {
                    const settings = {};
                    const forms = document.querySelectorAll('form[data-settings]');
                    forms.forEach(form => {
                        const formData = new FormData(form);
                        const category = form.dataset.settings;
                        settings[category] = {};
                        for (let [key, value] of formData.entries()) {
                            settings[category][key] = value;
                        }
                    });

                    localStorage.setItem('chronos_settings', JSON.stringify(settings));
                    showToast('Warnung', 'Einstellungen nur lokal gespeichert: ' + error.message, 'warning');
                } catch (localError) {
                    showToast('Fehler', 'Einstellungen konnten nicht gespeichert werden: ' + error.message, 'error');
                }
            }
        }

        async function testCalDAVConnection() {
            try {
                showToast('Info', 'Teste CalDAV-Verbindung...', 'info');

                // Get CalDAV settings from form
                const caldavForm = document.querySelector('form[data-settings="caldav"]');
                if (!caldavForm) {
                    throw new Error('CalDAV-Einstellungsformular nicht gefunden');
                }

                const formData = new FormData(caldavForm);
                const caldavSettings = {
                    server_url: formData.get('server_url') || formData.get('caldav_server'),
                    username: formData.get('username') || formData.get('caldav_username'),
                    password: formData.get('password') || formData.get('caldav_password')
                };

                // Validate required fields
                if (!caldavSettings.server_url) {
                    throw new Error('Server-URL ist erforderlich');
                }

                // Test CalDAV connection with actual settings
                const response = await fetch('/api/v1/caldav/test-connection', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${window.CHRONOS_CONFIG.API_KEY}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(caldavSettings)
                });

                if (!response.ok) {
                    throw new Error(`API error: ${response.status}`);
                }

                const result = await response.json();

                if (result.success) {
                    const details = result.details || {};
                    const message = `CalDAV-Verbindung erfolgreich! ${
                        details.calendar_count ? `${details.calendar_count} Kalender gefunden.` : ''
                    }`;
                    showToast('Erfolg', message, 'success');

                    // Update connection status indicator
                    const statusIndicator = document.querySelector('.caldav-status');
                    if (statusIndicator) {
                        statusIndicator.textContent = '‚úÖ Verbunden';
                        statusIndicator.className = 'caldav-status status-success';
                    }
                } else {
                    throw new Error(result.message || 'Verbindung fehlgeschlagen');
                }

            } catch (error) {
                console.error('CalDAV connection test failed:', error);
                showToast('Fehler', `CalDAV-Verbindungstest fehlgeschlagen: ${error.message}`, 'error');

                // Update connection status indicator
                const statusIndicator = document.querySelector('.caldav-status');
                if (statusIndicator) {
                    statusIndicator.textContent = '‚ùå Getrennt';
                    statusIndicator.className = 'caldav-status status-error';
                }
            }
        }

        function regenerateApiKey() {
            if (confirm('Sind Sie sicher? Der alte API-Schl√ºssel wird ung√ºltig.')) {
                showToast('Info', 'Generiere neuen API-Schl√ºssel...', 'info');

                fetch('/api/v1/admin/regenerate-api-key', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${window.CHRONOS_CONFIG.API_KEY}`
                    }
                })
                .then(response => response.json())
                .then(result => {
                    if (result.success) {
                        window.CHRONOS_CONFIG.API_KEY = result.new_key;
                        showToast('Erfolg', 'API-Schl√ºssel erfolgreich erneuert!', 'success');

                        // Update displayed key
                        const keyDisplay = document.getElementById('apiKeyDisplay');
                        if (keyDisplay) {
                            keyDisplay.textContent = result.new_key;
                        }
                    } else {
                        showToast('Fehler', 'API-Schl√ºssel konnte nicht erneuert werden.', 'error');
                    }
                })
                .catch(error => {
                    showToast('Fehler', 'Fehler beim Erneuern des API-Schl√ºssels: ' + error.message, 'error');
                });
            }
        }

        // Load settings on page load
        function loadSettings() {
            try {
                const settings = localStorage.getItem('chronos_settings');
                if (settings) {
                    const parsed = JSON.parse(settings);

                    // Apply loaded settings to forms
                    Object.keys(parsed).forEach(category => {
                        const form = document.querySelector(`form[data-settings="${category}"]`);
                        if (form) {
                            Object.keys(parsed[category]).forEach(key => {
                                const field = form.querySelector(`[name="${key}"]`);
                                if (field) {
                                    if (field.type === 'checkbox') {
                                        field.checked = parsed[category][key] === 'on';
                                    } else {
                                        field.value = parsed[category][key];
                                    }
                                }
                            });
                        }
                    });
                }
            } catch (error) {
                console.warn('Could not load settings:', error);
            }
        }

        // Global function registration
        window.closeSidebar = closeSidebar;
        window.toggleSidebar = toggleSidebar;
        window.viewEventDetails = viewEventDetails;
        window.refreshCalendar = refreshCalendar;
        window.navigateCalendar = navigateCalendar;
        window.goToToday = goToToday;
        window.switchView = switchView;
        window.viewAllDayEvents = viewAllDayEvents;
        window.refreshAnalytics = refreshAnalytics;
        window.exportAnalytics = exportAnalytics;
        window.setTimeRange = setTimeRange;
        window.switchChartType = switchChartType;
        window.applyInsight = applyInsight;
        window.dismissInsight = dismissInsight;
        window.generateReport = generateReport;
        window.createNewTemplate = createNewTemplate;
        window.saveTemplate = saveTemplate;
        window.editTemplate = editTemplate;
        window.useTemplate = useTemplate;
        window.deleteTemplate = deleteTemplate;
        window.saveSettings = saveSettings;
        window.testCalDAVConnection = testCalDAVConnection;
        window.regenerateApiKey = regenerateApiKey;
        window.loadSettings = loadSettings;

        // Function to show all events (called from "Alle Events anzeigen" button)
        window.showAllEvents = function() {
            window.location.href = '/events';
        };

        // Enhanced error recovery for high-volume scenarios
        window.addEventListener('error', function(e) {
            console.error('Global error caught:', e.error);
            if (e.error && e.error.message.includes('dashboard')) {
                showToast('Wiederherstellung', 'Dashboard wird automatisch wiederhergestellt', 'info');
                setTimeout(() => {
                    loadDashboardData().catch(() => {
                        console.log('Automatic recovery failed, using fallback state');
                    });
                }, 2000);
            }
        });

        // Enhanced unhandled promise rejection handling
        window.addEventListener('unhandledrejection', function(e) {
            console.warn('Unhandled promise rejection:', e.reason);
            if (e.reason && typeof e.reason === 'object' && e.reason.message) {
                if (e.reason.message.includes('fetch') || e.reason.message.includes('network')) {
                    console.log('Network error detected, dashboard will use cached/default data');
                    e.preventDefault(); // Prevent the error from being logged to console
                }
            }
        });

        // Auto-load settings when page loads
        document.addEventListener('DOMContentLoaded', loadSettings);
    </script>

    <!-- Service Worker Registration removed - not implemented yet -->
</body>
</html>